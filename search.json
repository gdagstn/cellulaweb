[
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Usage",
    "section": "",
    "text": "The pipelines in cellula assume that you are working with the output of CellRanger (or something similar) and you imported it into a SingleCellExperiment object (hereafter SCE) using the TENxIO package. This is relevant for gene identifiers, since the rowData slot of the SCE will have a “Symbol” and a “ID” column.\nFor demo purposes we can use a publicly available dataset, Segerstolpe et al. 2016[2], which we retrieve using the scRNAseq package:\n\n# BiocManager::install(\"scRNAseq\") \nsce &lt;- scRNAseq::SegerstolpePancreasData()\ncolnames(rowData(sce)) = c(\"Symbol\", \"ID\")\n\nAssuming that you have formed a SCE object containing the “individual” column that identifies different batches, you can run an integration pipeline as follows:\n\nsce &lt;- cellula(sce, name = \"myproject\", batch = \"individual\", \n                integration_method = \"Harmony\",\n                verbose = TRUE, save_plots = TRUE)\n\nThe name argument defines the name of the folder that will be created to store files and plots. We set verbose = TRUE to print the progress of the pipeline. Setting save_plots = TRUE will create a few QC plots in the name/plots folder: total UMI, total genes detected, UMI x genes; optionally % MT, % Ribo and %MALAT1, total UMI x doublet class. Plots are separated according to whether the cells were discarded or not in the filtering step.\nThe cellula() function is a wrapper around a few modules or sub-pipelines that have different degrees of customization.\nThere are other independent functions that are not run through cellula() as they need some user input, e.g. findTrajectories() requires the user to specify the starting cluster (through makeGraphsAndClusters()), or the cluster labels to use.\nThe scheme is:\ncellula()\n    ├── Quality Control [QC]\n    |    ├── run emptyDrops (optional) [QC/EMPTY]\n    |    ├── score mito/ribo/malat1 subsets (optional)\n    |    ├── filter out (optional)\n    |    └── doublet finding (optional) [QC/DBL]\n    ├── Normalization and dimensionality reduction [NOR]\n    |    ├── pre-clustering\n    |    ├── computing pooled factors\n    |    ├── log-normalization (simple or multi-batch)\n    |    ├── HVG finding (simple or multi-batch)\n    |    ├── PCA\n    |    └── UMAP\n    ├── Integration [INT] (optional) - choose one method\n    |    ├── fastMNN [INT/MNN]\n    |    |    ├── integration\n    |    |    └── UMAP\n    |    ├── Seurat [INT/SEURAT]\n    |    |    ├── conversion to Seurat\n    |    |    ├── normalization and HVG finding\n    |    |    ├── find integration anchors\n    |    |    ├── integrate data\n    |    |    ├── scale data\n    |    |    ├── PCA\n    |    |    └── UMAP\n    |    ├── LIGER [INT/LIGER]\n    |    |    ├── conversion to LIGER\n    |    |    ├── normalization\n    |    |    ├── HVG finding\n    |    |    ├── scale data\n    |    |    ├── NMF\n    |    |    ├── quantile normalization\n    |    |    └── UMAP\n    |    ├── Harmony [INT/HARMONY]\n    |    |    ├── Harmony matrix (on PCA)\n    |    |    └── UMAP\n    |    └── Regression [INT/regression]\n    |    |    ├── regression on logcounts\n    |    |    ├── PCA\n    |    |    └── UMAP\n    |    ├── scMerge2 [INT/scMerge2]\n    |    |    ├── Pseudobulk and RUV\n    |    |    └── UMAP\n    |    └── STACAS [INT/STACAS]\n    |         ├── conversion to Seurat\n    |         ├── normalization and HVG finding\n    |         ├── STACAS integration\n    |         ├── PCA\n    |         └── UMAP    \n    └── Cell type annotation [ANNO] (optional) - choose one method\n              ├── Seurat AddModuleScore\n              ├── ssGSEA\n              ├── UCell\n              ├── AUCell\n              └── Jaitin\n              \n  makeGraphsAndClusters()\n    └── Multi-resolution clustering [CLU]\n          ├── sweep on Louvain/Leiden resolution or SNN neighbor numbers\n          ├── calculate modularity (optional)\n          └── calculate silhouette (optional)\n              \n  findTrajectories()            \n    └── Trajectory estimation [TRAJ]\n          ├── slingshot [TRAJ/slingshot]\n          |   ├── get lineages\n          |   ├── calculate principal curves\n          |   ├── embed in 2D (optional)\n          |   └── calculate per-lineage DE (optional)\n          └── monocle3 [TRAJ/monocle]\n              ├── convert to CellDataSet\n              ├── learn graph\n              └── embed in 2D (optional)\n                   ├── populate FR layout (if dr_embed = \"FR\")\n                   └── UMAP on FR layout (if dr_embed = \"FR\")\n             \nMost of the choices can be made around the integration method. cellula has implemented 5 methods: fastMNN[3],[4] and regressBatches from the batchelor package, Harmony[5], the CCA-based Seurat[6] method, non-negative matrix factorization (NMF) from LIGER[7] through the rliger and RccPlancs packages, a pseudobulk and RUV-based method, scMerge2 from the scMerge package[8], and the Seurat-based STACAS integration method from the eponymous package[9].\nLIGER and Seurat integration methods require an intermediate step where package-specific objects are created and some pre-processing steps are repeated again according to the best practices published by the authors of those packages.\nEach step of the pipeline can be called independently on the object:\n\nsce &lt;- doQC(sce, name = \"segerstolpe\", batch = \"individual\", save_plots = TRUE)\nsce &lt;- doNormAndReduce(sce, name = \"segerstolpe\", batch = \"individual\")\nsce &lt;- integrateSCE(sce, batch = \"individual\", method = \"Seurat\")\n\nDoublet identification is carried out through the scDblFinder package[10] using standard defaults."
  },
  {
    "objectID": "cellcycle.html",
    "href": "cellcycle.html",
    "title": "Scoring the cell cycle",
    "section": "",
    "text": "cellula implements one method for cell cycle scoring, as done by the tricycle package by Zheng and colleagues.\nThe assignCellCycle() function is a simple wrapper to tricycle with a couple added features: two methods to determine the origin of the PCA point cloud automatically, and a simple way to infer the cell cycle phase (as a categorical vector) using the authors’ indications.\n\nsce = assignCellCycle(sce)\n\nThe methods for recentering (recenter argument) are:\n\noptim an optimization routine that finds the point within the PCA point cloud that is farthest from all other points (by Pierre-Luc Germain)\nchull finds the center by finding the centroid of the convex hull of the cloud\nnone takes (0,0) as center.\n\nAdditional parameters feed directly into the tricycle::estimate_cycle_position() function, in particular:\n\ngname.type the type of gene names (rownames of the SCE object), either \"SYMBOL\" or \"ENSEMBL\"\ngname the rowData(sce) column with gene identifiers, if not rownames\nexpres_values the assay to use to project data on the reference space.\n\nThe plotCellCycle() function takes tricycle results and plots them in a circular embedding in which the position of each cell reflects the cell cycle phase it is estimated to be in.\nThe rings_by argument controls how many rings the data will be divided into: it can be clusters, samples, batches, etc.\nThe colour_by argument controls the data used for the color scale. By default it is the position (angle) on the projection, which, being cyclical, requires a cyclical color palette.\n\n# Let's make shorter labels\nsce$labels_AUC = gsub(sce$labels_AUC, pattern = \"MURARO_PANCREAS_\", replacement = \"\")\nsce$labels_AUC = gsub(sce$labels_AUC, pattern = \"_CELL\", replacement = \"\")\n\nplotCycle(sce, rings_by = \"labels_AUC\")"
  },
  {
    "objectID": "trajectories.html",
    "href": "trajectories.html",
    "title": "Trajectory inference",
    "section": "",
    "text": "At the time of writing cellula only implements a wrapper around the slingshot method[20] and the monocle3 method [21] for pseudotemporal trajectory inference, and the testPseudotime() method from TSCAN[22] for differential expression along a trajectory. More trajectory inference and differential expression methods will be implemented in the future.\nThe monocle3 method has been originally developed to work on 2D embeddings such as UMAP, but given the distortion introduced by these embeddings this function allows users to input any embedding (such as PCA). Moreover, the monocle3 method originally allows partitions to be specified. In the current implementation partitions have been disabled.\nThe findTrajectories() function takes a SingleCellExperiment object as input, and requires the user to specify the method (one of \"slingshot\" or \"monocle\"), the cluster label which will be used as an input to the MST creation in slingshot, or to identify the starting node in monocle3.\nOther important parameters are:\nThe output is the same object used in the input, with some additional fields.\nIn this example we download a dataset that captures early haematopoietic differentiation from Nestorowa et al. [23] and we do a quick processing and clustering.\nsce2 = scRNAseq::NestorowaHSCData()\n\nsce2 = cellula(sce2, name = \"nestorowa\", do_qc = FALSE)\n\nsce2 = makeGraphsAndClusters(sce2, space = reducedDim(sce2, \"PCA\")[,1:20])\n\nplot_UMAP(sce2, umap_slot = \"UMAP\", color_by = \"SNN_0.64\", label_by = \"SNN_0.64\")\nThen we take an arbitrary starting point (cluster 7) and calculate trajectories with both slingshot and monocle using the same space (PCA, first 20 components).\nsce2 = findTrajectories(sce2, dr = \"PCA\", \n                        method = \"monocle\",\n                        ndims = 20, clusters = \"SNN_0.64\", \n                        dr_embed = \"UMAP\", start = 7)\n                        \nsce2 = findTrajectories(sce2, dr = \"PCA\", \n                        method = \"slingshot\",\n                        ndims = 20, clusters = \"SNN_0.64\", \n                        dr_embed = \"UMAP\", start = 7)\nNow we can visualize results on the UMAP since we specified a dr_embed parameter. Notice how slingshot will identify different pseudotimes (one per lineage) while monocle3 will identify a single pseudotime. Moreover, the plot_UMAP() function can include a trajectory argument which points to the name of the element in the metadata slot containing segments to draw trajectories.\nplot_UMAP(sce2, umap_slot = \"UMAP\", color_by = \"slingPseudotime_1\", \n           label_by = \"SNN_0.64\", trajectory = \"Slingshot_embedded_curves\")\n plot_UMAP(sce2, umap_slot = \"UMAP\", color_by = \"monoclePseudotime\", \n           label_by = \"SNN_0.64\", trajectory = \"Monocle_embedded_curves\")\nSince the 2D embedding of monocle3 PCA-derived trajectories may be hard to understand, given the distortions introduced by UMAP, cellula includes an additional 2D embedding method, dr_embed = \"FR\", inspired båy the PAGA embedding initialization technique [24].\nBriefly, once the principal graph has been calculated, it is laid out in 2D using the Fruchterman-Reingold algorithm. Then each cell is randomly plotted around their closest vertex in the graph, and reordered according to pseudotime value. This semi-random layout is used as an initialization for UMAP, which will optimize the point positions. The resulting layout is more visually pleasing and reflects more accurately the positions of cells with respect to the trajectory (although not necessarily to each other).\nThis FR-initialized UMAP is stored in a reducedDim slot named UMAP_FR.\nsce2 = findTrajectories(sce2, clusters = \"SNN_0.64\", method = \"monocle\",\n        dr = \"PCA\", ndims = 20, start = \"7\", dr_embed = \"FR\")\n        \nplot_UMAP(sce2, umap_slot = \"UMAP_FR\", color_by = \"monoclePseudotime\", \n           label_by = \"SNN_0.64\", trajectories = \"Monocle_embedded_curves\")\nIt should be noted that this layout is, in a way, optimized for trajectories rather than global cell-cell similarity and as always should only be treated as a visualization tool."
  },
  {
    "objectID": "trajectories.html#metacells",
    "href": "trajectories.html#metacells",
    "title": "Trajectory inference",
    "section": "Metacells",
    "text": "Metacells\nIn order to speed up calculations and overcome sparsity, cells can be aggregated into metacells using k-means clustering with a high k.\nClustering is carried out in the reduced dimensional space of choice selected through the space argument, and it is carried out in each level of group separately.\nRather than selecting the number of clusters k, the function takes an average number of cells per cluster w which is used to determine k (default is w = 10 cells per cluster). Read counts are aggregated by gene across all cells within each cluster, resulting in metacells. These can be used as input to findTrajectories() or other operations such as clustering, downsampling, signature scoring, etc.\nIn this example we create metacells aggregating (on average) 10 cells, within each cluster from the “SNN_0.5” clustering results:\n\nsce_meta &lt;- makeMetacells(sce, group = \"SNN_0.5\", space = \"PCA_Harmony\", w = 10)"
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installing cellula",
    "section": "",
    "text": "Use remotes, devtools or BiocManager to install. The BiocManager installation is probably the best one, as it will be able to fetch all the Bioconductor dependencies automatically.\n\n# recommended\nBiocManager::install(\"gdagstn/cellula\")\n\nremotes::install_github(\"gdagstn/cellula\")\ndevtools::install_github(\"gdagstn/cellula\")"
  },
  {
    "objectID": "install.html#installation",
    "href": "install.html#installation",
    "title": "Installing cellula",
    "section": "",
    "text": "Use remotes, devtools or BiocManager to install. The BiocManager installation is probably the best one, as it will be able to fetch all the Bioconductor dependencies automatically.\n\n# recommended\nBiocManager::install(\"gdagstn/cellula\")\n\nremotes::install_github(\"gdagstn/cellula\")\ndevtools::install_github(\"gdagstn/cellula\")"
  },
  {
    "objectID": "install.html#dependencies",
    "href": "install.html#dependencies",
    "title": "Installing cellula",
    "section": "Dependencies",
    "text": "Dependencies\ncellula is dependency-heavy, which is not something I’m proud of, but makes sense considering this is a wrapper to a series of different analytical approaches. However, to keep the actual dependency tree lighter for the package itself, as many dependencies as possible have been moved to the Suggests part of the DESCRIPTION.\nThis way, necessary packages for specific methods will be checked only when executing functions that depend on those packages. This means that cellula won’t ask you to install Seurat until the moment you want to use Seurat integration or module scoring. This may be a little more tedious than having all the dependencies ready at the beginning, but it feels like a better solution than shoehorning 30+ dependencies at first install. Moreover, if you’ve been working with single cell analysis for a bit, you probably have most of these already installed.\nShould you want to install all optional dependencies at once before installing cellula, you can install them as follows:\n\nBiocManager::install(c(\"DropletUtils\", \"scDblFinder\", \"AUCell\", \"harmony\", \"GSVA\", \n                     \"Seurat\", \"rliger\", \"tricycle\", \"UCell\", \"slingshot\", \n                     \"cole-trapnell-lab/monocle3\", \"destiny\", \"carmonalab/STACAS\",\n                     \"welch-lab/RcppPlanc\"))\n\nMoreover, if you want to install Bioconductor non-optional dependencies separately (e.g. to install cellula using remotes) you can install them as follows:\n\nBiocManager::install(c(\"SingleCellExperiment\", \"SummarizedExperiment\", \n                       \"BiocNeighbors\", \"scran\", \"scater\", \"scuttle\", \"bluster\", \n                       \"batchelor\", \"BiocParallel\", \"S4Vectors\", \"TSCAN\"))"
  },
  {
    "objectID": "downsampling.html",
    "href": "downsampling.html",
    "title": "Downsampling",
    "section": "",
    "text": "There are two ways to downsample data in cellula: downsampling reads and downsampling cells.\nThe first approach simulates reads randomly sampling counts from a distribution with a fixed total number, using a vector of probabilities equivalent to the per-gene proportion of reads within each cell.\nBriefly, let’s consider a cell C in which genes a, b, and c have been quantified with 50, 30, 20 counts each (totaling to 100 counts). This is equivalent to a bag of marbles in which the probability of randomly picking an a marble is 50/100 = 0.5, b marble is 0.3, and c marble is 0.2.\nIf we want to downsample C to a total of 40 counts (yielding the downsampled C’), we randomly pick 40 counts from a (0.5, 0.3, 0.2) vector of probabilities.\nThis is a sort of downsampling by simulation and is described in Scott Tyler’s work[19], reimplemented in cellula with a slightly faster optimization.\nThe downsampleCounts() uses a minimum count number that is user-defined (or the minimum total count number in the dataset as a default) and returns a SingleCellExperiment object with the same number of cells as the input, and a down-sampled count matrix where each cell has the same total number of counts.\nThe second approach randomly select cells from within groups such as clusters, batches, or a combination of the two.\nCells are randomly selected so that they represent a user-defined fraction of the within-group total, with some lower bound to ensure that small groups are represented: if a rare cluster label only contains 9 cells and we want to downsample a dataset to 10%, we can cap the minimum to 5 cells so that we ensure the rare label is still adequately represented.\nThe downsampleCells() function returns a SingleCellExperiment object with fewer cells than the input, as defined by the proportion and min parameters."
  },
  {
    "objectID": "clustering.html",
    "href": "clustering.html",
    "title": "Clustering",
    "section": "",
    "text": "cellula offers a wrapper around clustering functions. For now, only SNN-based Louvain[11] and Leiden[12] clustering are implemented. The makeGraphsAndClusters() function allows users to do parameter sweeps along either the number of neighbors or the resolution of the clustering.\nIn this example we sweep along the value of the resolution parameter for a Louvain clustering. For the SNN graph constructions, edges are weighted according to the jaccard index of their shared neighbors, mimicking the Seurat graph construction and clustering procedure:\nsce &lt;- makeGraphsAndClusters(sce, k = c(0.1, 0.25, 0.5, 0.75, 1),\n                             dr = \"PCA_Harmony\", ndims = 20,\n                             sweep_on = \"clustering\", method = \"louvain\", \n                             weighting_scheme = \"jaccard\", prefix = \"SNN_\",\n                             verbose = TRUE)\nIf another integration method has been run on the same object (e.g. Seurat integration), then the clustering can be performed on that integrated space by specifying the dr argument (in this case, \"PCA_Seurat\"):\nsce &lt;- makeGraphsAndClusters(sce, k = c(0.1, 0.25, 0.5, 0.75, 1), \n                             dr = \"PCA_Seurat\", ndims = 20,\n                             sweep_on = \"clustering\", method = \"louvain\", \n                             weighting_scheme = \"jaccard\", prefix = \"Seurat_SNN_\",\n                             verbose = TRUE)\nThe default value for space is NULL and will use the \"PCA\" slot from the reducedDim() accessor."
  },
  {
    "objectID": "clustering.html#plotting-clustering-results",
    "href": "clustering.html#plotting-clustering-results",
    "title": "Clustering",
    "section": "Plotting clustering results",
    "text": "Plotting clustering results\nYou can visualize clustering results on the UMAP using the plot_UMAP() function, adding labels if desired:\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"SNN_0.5\", label_by = \"SNN_0.5\")\n\n\nIf using the clustree package[13], the clustering tree can be visualized by using the same prefix defined in makeGraphsAndClusters():\n\nlibrary(clustree)\nclustree(sce, prefix = \"SNN_\")\n\n\nThe default arguments to the clustering wrapper include the generation of modularity and approximate silhouette scores for every clustering round. These will be stored in the metadata of the SCE, named according to the prefix, the resolution, and the \"modularity_\" and \"silhouette_\" prefixes. Silhouette and modularity can be visualized by using the dedicated functions:\n\nplotSilhouette(sce, \"SNN_0.5\")\n\nplotModularity(sce, \"SNN_0.5\")\n\n \nAs seen in the Plotting section, you can plot cluster markers using the presto package and the plot_dots() function:\n\n# Install {presto}\nremotes::install_github(\"immunogenomics/presto\")\n\n# Quick and dirty marker calculation\nmarkers = presto::wilcoxauc(sce, group_by = \"SNN_0.5\")\nmarkerlist = split(markers, markers$group)\n\nfor(i in seq_len(length(markerlist))) {\n  markerlist[[i]]$deltapct = markerlist[[i]]$pct_in - markerlist[[i]]$pct_out\n  markerlist[[i]] = markerlist[[i]][order(markerlist[[i]]$deltapct, decreasing = TRUE),]\n}\n\ntop5 = lapply(markerlist, function(x) x$feature[1:5])\nmarkergenes =  Reduce(union, top5)\n\nplot_dots(sce, genes = top5, group_by = \"SNN_0.5\")"
  },
  {
    "objectID": "clustering.html#metaclusters",
    "href": "clustering.html#metaclusters",
    "title": "Clustering",
    "section": "Metaclusters",
    "text": "Metaclusters\nAditionally, metaclusters can also be identified. A metacluster is a cluster of clusters obtained by different clustering methods. Clusters across methods are linked acording to how many cells they share, and these links become edges of a graph. Then, Louvain clustering is run on the graph and the communities that are identified are metaclusters. These metaclusters show the relationship between clustering methods. Moreover, they can be used to understand cluster stability along different parameters and/or integration methods. A cell can belong to different clusters according to the clustering method (i.e. to the resolution or to the space that was used). If a cell belongs to clusters that are consistently included in a metacluster, then that cell belongs to a “stable” cluster. If instead the cell belongs to clusters that have different metacluster assignments, then it’s in an “unstable” position, meaning it may be clustered differently according to integration methods and/or resolutions.\nThe metaClusters() function takes a clusters argument, which is a vector of column names from the colData of the SCE where clustering results are stored. In this example it is easy to isolate by using grep() and searching for the prefix “SNN_”.\n\nclusterlabels &lt;- colnames(colData(sce))[grep(\"SNN_\", colnames(colData(sce)))]\nsce &lt;- metaCluster(sce, clusters = clusterlabels)\n\n\nEvery cell will belong to a series of clusters, which in turn belong to a metacluster. For every cell, we count how many times they are assigned to a particular metacluster, and the maximum metacluster is assigned, together with a “metacluster score” (i.e. the frequency of assignment to the maximum metacluster) and whether this score is above or below a certain threshold (0.5 by default). These columns are saved in the colData slot of the SCE.\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"metacluster_score\", label_by = \"SNN_0.5\")"
  },
  {
    "objectID": "parallelization.html",
    "href": "parallelization.html",
    "title": "Parallelization",
    "section": "",
    "text": "Since cellula is mostly based on R/Bioconductor packages, it offers the BiocParallel parallelization backend through its parallel_param argument. In some cases, e.g. the Seurat integration, another type of backend has to be set up separately outside of the function call.\nBiocParallel parallelization is implemented where possible, i.e. all the steps of the pipeline where it is sensible to use them (PCA, clustering, integration…).\n\nsce &lt;- integrateSCE(sce, batch = \"individual\", \n                    method = \"fastMNN\", \n                    parallel_param = MulticoreParam(workers = 4))"
  },
  {
    "objectID": "identities.html",
    "href": "identities.html",
    "title": "Assigning identities",
    "section": "",
    "text": "cellula implements 5 methods for automated cell identity assignment, 4 of which are signature-based, and one reference-based. The methods are based on the Bioconductor AUCell package[14], the GSVA ssGSEA implementation[15], the Seurat AddModuleScore() function, the UCell method[16] and the Jaitin method[17].\nFor the first 4 methods (\"AUCell\", \"ssGSEA\", \"AddModuleScore\" and \"UCell\") the function requires user-defined genesets, i.e. a named list containing genes to be used for scoring every single cell. These can be obtained through other packages, e.g. msigdbr. For instance, if we wanted to take all the Muraro et al.[18]. signature genes, present in the C8 collection, we would do:\n\nlibrary(msigdbr)\n\ntype_genes = msigdbr(\"Homo sapiens\", category = \"C8\")\n\ngenesets = lapply(split(type_genes, type_genes$gs_name), function(x) x$gene_symbol)\n\nmuraro_genes = genesets[grep(\"MURARO\", names(genesets))]\n\nThen, we would use the assignIdentities() function from cellula to calculate signature scores:\n\nsce = assignIdentities(sce, \n                       genesets = muraro_genes, \n                       method = \"AUC\")\n\nOther signature-based methods are \"Seurat\", \"UCell\", and \"ssGSEA\".\nA reference-based method, \"Jaitin\", is available. This method uses a matrix of gene expression as a reference, and then calculates the posterior probability for each cell in the sce object that its transcriptome matches any of the reference ones. The reference with the highest probability is selected as the best label. Importantly, for the “Jaitin” method it is possible to choose the assay to be used. If the user supplies a matrix of log-normalized counts as a reference, the assay argument should point to a similarly normalized data, e.g. \"logcounts\".\nassignIdentities() will create a column named “labels_AUC” (or anything else the user determines using the name argument) in the colData(sce). Assignments can be plotted:\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"labels_AUC\")\n\n\nYou can now see why it can be useful to plot a confusion matrix as a heatmap:\n\nplot_Coldata(sce, x = \"SNN_0.5\", y = \"labels_AUC\")\n\n\nYou can also use single signatures as an input, which will result in adding the score to the colData slot of the SCE directly, rather than an assignment:\n\nsce &lt;- assignIdentities(sce, \n                        genesets = muraro_genes$BETA_CELL, \n                        method = \"AUC\", \n                        name = \"Beta_Cell_signature\")\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"Beta_Cell_signature\")\n\n\nThe \"UCell\" method works well when you have small signatures (e.g. even 2/3 genes). It allows you to specify positive and negative labels, which is useful when you are sure the identity of a cell types depends on the lack of expression of certain markers (see hematopoietic lineages). To do so, you can add “+” or “-” to each gene."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cellula",
    "section": "",
    "text": "This is the companion website to the cellula package.\ncellula is a simple R-based pipeline for single cell RNA-seq processing with a number of methods for integration and identity assignment.\ncellula follows the practices outlined in the OSCA book [1], with some additional options for integration/batch effect correction methods, signature scoring, and downsampling.\nAs a one-stop solution, this package tends to make choices for the users, with the caveat that these choices follow either defaults or sensible implementations. However, this means that a certain degree of freedom is removed from the end user. This assumes that users who desire total control on the process (or granular specification of parameters) do not need cellula and would be more comfortable setting up their own analysis pipelines.\ncellula exists to automate and share routine analyses the way I usually do them, and offer “quick and dirty” access for exploratory data analysis.\ncellula is very much under active development, and any feedback and contribution are welcome through the Issues page.\nWhere did the name “papplain” come from? it’s an inside joke with some friends and ex colleagues.\nWhy did you change it to “cellula”? one day I’d like to share this tool and I need a name that is not too dumb."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "[1] Amezquita et al. Nat Methods. 2020 Feb; 17(2): 137–145\n [2] Segerstolpe et al. Cell Metab. 2016 Oct 11; 24(4): 593–607.\n [3] Haghverdi et al. Nat Biotechnol. 2018 Jun;36(5): 421-427.\n [4] Lun ATL. https://marionilab.github.io/FurtherMNN2018/theory/description.html\n [5] Korsunsky et al. Nat Methods. 2019 Dec;16(12): 1289-1296.\n [6] Stuart et al. Cell. 2019 Jun 13;177(7): 1888-1902.e21.\n [7] Welch et al. Cell. 2019 Jun 13; 177(7): 1873–1887.e17.\n [8] Germain et al. F1000Res. 2021; 10: 979\n [9] Blondel et al. J. Stat. Mech. 2008; P10008\n [10] Traag et al. Sci Rep. 2019; 9:5233.\n [11] Zappia and Oshlack Gigascience. 2018 Jul; 7(7): giy083.\n [12] Aibar et al. Nat Methods. 2017 Nov; 14(11): 1083–1086.\n [13] Hänzelmann et al. BMC Bioinformatics. 2013 Jan 16;14: 7.\n [14] Andreatta and Carmona Comput Struct Biotechnol J. 2021 Jun 30;19: 3796-3798.\n [15] Jaitin et al. 2015 Science 343, 776-779\n [16] Muraro et al. Cell Syst. 2016 Oct 26;3(4):385-394.e3\n [17] Tyler et al. biorXiv 2021 11.15.468733\n [18] Street et al. BMC Genomics. 2018 Jun 19;19(1): 477.\n [19] Cao et al. Nature. 2019 Feb;566(7745):496-502\n [20] Ji and Ji https://www.bioconductor.org/packages/release/bioc/html/TSCAN.html\n [21] Nestorowa et al. Blood. 2016 Aug 25;128(8):e20-31\n [22] Wolf et al. Genome Biol. 2019 Mar 19;20(1):59"
  },
  {
    "objectID": "plotting.html",
    "href": "plotting.html",
    "title": "Plotting",
    "section": "",
    "text": "cellula implements a few simple plotting functions for exploratory data analysis."
  },
  {
    "objectID": "plotting.html#color-palettes",
    "href": "plotting.html#color-palettes",
    "title": "Plotting",
    "section": "Color palettes",
    "text": "Color palettes\ncellula has a few standard color palettes for data visualization, which were lifted from different packages. All plotting functions allow the user to input their custom palettes.\n\nStandard qualitative\nThe standard qualitative palette comes from iterations of the qualpalr package in the default implementation of qualpal(). These palettes are optimized for maximal color differences in a perceptual space, i.e. by finding the N farthest points in the DIN99 color space. Since the number of colors will change the coordinates, using 2, 3, 4, … N colors will create different palettes.\nThis is automatically selected by default when the data is categorical, e.g. for clusters, samples, etc. It can be selected manually by specifying color_palette = \"Qualpal\" where possible.\n\n\n\nCVD-adjusted qualitative\nThere are two qualitative palettes from qualpalr adjusted for Color Vision Deficiency (CVD) using a severity of 0.5. One is adjusted for protanopia and one for tritanopia.\n\nThey can be selected by specifying color_palette = \"Protan\" or color_palette = \"Tritan\" where possible.\n\n\n\nOther qualitative palettes\ncellula offers a few alternative qualitative palettes out of the box, with different sizes.\n\nTableau: the Tableau palette contains 10 colors. This palette is not optimized for CVD and is not maximally separated, just pleasant to look at. The Tableau palette comes from base R.\n\n\n\nPear: the Pear18 palette contains 18 colors. This palette is not optimized for CVD and is not maximally separated, just pleasant to look at. The Pear18 palette comes from a subset of the original Pear36 palette on Lospec by user PineappleOnPizza.\nPolychrome: the Polychrome24 palette contains 24 colors. This palette is not optimized for CVD and is not maximally separated, just pleasant to look at. The Polychrome24 palette comes from a subset of the Polychrome36 palette from base R.\nPolylight: the Polychrome24 palette containst 24 colors. This palette is not optimized for CVD and is not maximally separated, just pleasant to look at. This is the Polychrome24 palette lightened by a factor of 0.4 using colorspace::lighten().\n\n\n\n\nQuantitative palettes\nThe Sunset, Heat and truncated Yellow-Green-Blue (YlGnBu) quantitative palette comes from the colorspace package, through the sequential_hcl() function using 25 colors (Sunset and Heat), 40 colors truncated to the last 30 (YlGnBu).\nThe Parula and Turbo quantitative palettes come from the pals package, using the parula() and turbo() functions respectively, both using 25 colors.\nSunset is the default palette for quantitative data in dimensionality reductions. YlGnBu is the default palette for quantitative data in dot plots and heatmaps. Heat 2 is the palette for kernel densities on scatterplots. Parula and Turbo are there just for testing purposes but can be chosen using color_palette = \"Parula\" or color_palette = \"Turbo\" where possible."
  }
]